import EventEmitter from "./EventEmitter";
export interface MagicArray<T, NOT_FOUND = never> extends Array<T> {
    not_found: NOT_FOUND[];
}
export default class MagicEmitter<T, NOT_FOUND = never> extends EventEmitter {
    private _ended;
    get ended(): boolean;
    private _cancelled;
    get cancelled(): boolean;
    private _willCancelAfterPage;
    get willCancelAfterPage(): boolean;
    private mappers;
    constructor();
    on(event: "data", listener: (data: T) => any): this;
    on(event: "not_found", listener: (data: NOT_FOUND) => any): this;
    on(event: "end", listener: (...args: any[]) => any): this;
    on(event: "cancel", listener: (...args: any[]) => any): this;
    on(event: "error", listener: (err: Error) => any): this;
    on(event: "done", listener: (...args: any[]) => any): this;
    emit(event: "data", data: T): boolean;
    emit(event: "not_found", data: NOT_FOUND): boolean;
    emit(event: "end"): boolean;
    emit(event: "cancel"): boolean;
    emit(event: "error", error: Error): boolean;
    emit(event: "done"): boolean;
    emitAll(event: "data", ...data: T[]): void;
    emitAll(event: "not_found", ...data: NOT_FOUND[]): void;
    cancel(): this;
    cancelAfterPage(): this;
    waitForAll(): Promise<MagicArray<T, NOT_FOUND>>;
    [Symbol.asyncIterator](): AsyncGenerator<T, void, unknown>;
    all(): AsyncGenerator<T, void, unknown>;
    notFound(): AsyncGenerator<NOT_FOUND, void, unknown>;
    map<T2>(mapper: (value: T) => T2): MagicEmitter<T2, NOT_FOUND>;
    private generate;
}
