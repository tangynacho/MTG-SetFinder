"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Card = exports.CardIdentifier = exports.CardSecurityStamp = exports.CardStatus = exports.CardFrame = exports.CardFinish = exports.PromoType = exports.RelatedCard = exports.RelatedCardComponent = exports.Format = exports.Layout = exports.Border = exports.Legality = exports.Game = exports.FrameEffect = exports.Rarity = exports.SortDirection = exports.Sort = exports.UniqueStrategy = void 0;
const IScry_1 = require("../IScry");
const Cached_1 = require("../util/Cached");
const MagicEmitter_1 = require("../util/MagicEmitter");
const MagicQuerier_1 = require("../util/MagicQuerier");
var UniqueStrategy;
(function (UniqueStrategy) {
    UniqueStrategy[UniqueStrategy["cards"] = 0] = "cards";
    UniqueStrategy[UniqueStrategy["art"] = 1] = "art";
    UniqueStrategy[UniqueStrategy["prints"] = 2] = "prints";
})(UniqueStrategy = exports.UniqueStrategy || (exports.UniqueStrategy = {}));
var Sort;
(function (Sort) {
    Sort[Sort["name"] = 0] = "name";
    Sort[Sort["set"] = 1] = "set";
    Sort[Sort["released"] = 2] = "released";
    Sort[Sort["rarity"] = 3] = "rarity";
    Sort[Sort["color"] = 4] = "color";
    Sort[Sort["usd"] = 5] = "usd";
    Sort[Sort["tix"] = 6] = "tix";
    Sort[Sort["eur"] = 7] = "eur";
    Sort[Sort["cmc"] = 8] = "cmc";
    Sort[Sort["power"] = 9] = "power";
    Sort[Sort["toughness"] = 10] = "toughness";
    Sort[Sort["edhrec"] = 11] = "edhrec";
    Sort[Sort["artist"] = 12] = "artist";
})(Sort = exports.Sort || (exports.Sort = {}));
var SortDirection;
(function (SortDirection) {
    SortDirection[SortDirection["auto"] = 0] = "auto";
    SortDirection[SortDirection["asc"] = 1] = "asc";
    SortDirection[SortDirection["desc"] = 2] = "desc";
})(SortDirection = exports.SortDirection || (exports.SortDirection = {}));
var Rarity;
(function (Rarity) {
    Rarity[Rarity["common"] = 0] = "common";
    Rarity[Rarity["uncommon"] = 1] = "uncommon";
    Rarity[Rarity["rare"] = 2] = "rare";
    Rarity[Rarity["special"] = 3] = "special";
    Rarity[Rarity["mythic"] = 4] = "mythic";
    Rarity[Rarity["bonus"] = 5] = "bonus";
})(Rarity = exports.Rarity || (exports.Rarity = {}));
var FrameEffect;
(function (FrameEffect) {
    FrameEffect[FrameEffect["legendary"] = 0] = "legendary";
    FrameEffect[FrameEffect["miracle"] = 1] = "miracle";
    FrameEffect[FrameEffect["nyxtouched"] = 2] = "nyxtouched";
    FrameEffect[FrameEffect["draft"] = 3] = "draft";
    FrameEffect[FrameEffect["devoid"] = 4] = "devoid";
    FrameEffect[FrameEffect["tombstone"] = 5] = "tombstone";
    FrameEffect[FrameEffect["colorshifted"] = 6] = "colorshifted";
    FrameEffect[FrameEffect["inverted"] = 7] = "inverted";
    FrameEffect[FrameEffect["sunmoondfc"] = 8] = "sunmoondfc";
    FrameEffect[FrameEffect["compasslanddfc"] = 9] = "compasslanddfc";
    FrameEffect[FrameEffect["originpwdfc"] = 10] = "originpwdfc";
    FrameEffect[FrameEffect["mooneldrazidfc"] = 11] = "mooneldrazidfc";
    FrameEffect[FrameEffect["moonreversemoondfc"] = 12] = "moonreversemoondfc";
    FrameEffect[FrameEffect["showcase"] = 13] = "showcase";
    FrameEffect[FrameEffect["extendedart"] = 14] = "extendedart";
    FrameEffect[FrameEffect["companion"] = 15] = "companion";
    FrameEffect[FrameEffect["etched"] = 16] = "etched";
    FrameEffect[FrameEffect["snow"] = 17] = "snow";
    FrameEffect[FrameEffect["lesson"] = 18] = "lesson";
    FrameEffect[FrameEffect["shatteredglass"] = 19] = "shatteredglass";
    FrameEffect[FrameEffect["convertdfc"] = 20] = "convertdfc";
    FrameEffect[FrameEffect["fandfc"] = 21] = "fandfc";
    FrameEffect[FrameEffect["upsidedowndfc"] = 22] = "upsidedowndfc";
})(FrameEffect = exports.FrameEffect || (exports.FrameEffect = {}));
var Game;
(function (Game) {
    Game[Game["paper"] = 0] = "paper";
    Game[Game["arena"] = 1] = "arena";
    Game[Game["mtgo"] = 2] = "mtgo";
})(Game = exports.Game || (exports.Game = {}));
var Legality;
(function (Legality) {
    Legality[Legality["legal"] = 0] = "legal";
    Legality[Legality["not_legal"] = 1] = "not_legal";
    Legality[Legality["restricted"] = 2] = "restricted";
    Legality[Legality["banned"] = 3] = "banned";
})(Legality = exports.Legality || (exports.Legality = {}));
var Border;
(function (Border) {
    Border[Border["black"] = 0] = "black";
    Border[Border["borderless"] = 1] = "borderless";
    Border[Border["gold"] = 2] = "gold";
    Border[Border["silver"] = 3] = "silver";
    Border[Border["white"] = 4] = "white";
})(Border = exports.Border || (exports.Border = {}));
var Layout;
(function (Layout) {
    Layout[Layout["normal"] = 0] = "normal";
    Layout[Layout["split"] = 1] = "split";
    Layout[Layout["flip"] = 2] = "flip";
    Layout[Layout["transform"] = 3] = "transform";
    Layout[Layout["modal_dfc"] = 4] = "modal_dfc";
    Layout[Layout["meld"] = 5] = "meld";
    Layout[Layout["leveler"] = 6] = "leveler";
    Layout[Layout["saga"] = 7] = "saga";
    Layout[Layout["adventure"] = 8] = "adventure";
    Layout[Layout["planar"] = 9] = "planar";
    Layout[Layout["scheme"] = 10] = "scheme";
    Layout[Layout["vanguard"] = 11] = "vanguard";
    Layout[Layout["token"] = 12] = "token";
    Layout[Layout["double_faced_token"] = 13] = "double_faced_token";
    Layout[Layout["emblem"] = 14] = "emblem";
    Layout[Layout["augment"] = 15] = "augment";
    Layout[Layout["host"] = 16] = "host";
    Layout[Layout["art_series"] = 17] = "art_series";
    Layout[Layout["double_sided"] = 18] = "double_sided";
})(Layout = exports.Layout || (exports.Layout = {}));
var Format;
(function (Format) {
    Format[Format["standard"] = 0] = "standard";
    Format[Format["future"] = 1] = "future";
    Format[Format["historic"] = 2] = "historic";
    Format[Format["gladiator"] = 3] = "gladiator";
    Format[Format["pioneer"] = 4] = "pioneer";
    Format[Format["explorer"] = 5] = "explorer";
    Format[Format["modern"] = 6] = "modern";
    Format[Format["legacy"] = 7] = "legacy";
    Format[Format["pauper"] = 8] = "pauper";
    Format[Format["vintage"] = 9] = "vintage";
    Format[Format["penny"] = 10] = "penny";
    Format[Format["commander"] = 11] = "commander";
    Format[Format["oathbreaker"] = 12] = "oathbreaker";
    Format[Format["brawl"] = 13] = "brawl";
    Format[Format["historicbrawl"] = 14] = "historicbrawl";
    Format[Format["alchemy"] = 15] = "alchemy";
    Format[Format["paupercommander"] = 16] = "paupercommander";
    Format[Format["duel"] = 17] = "duel";
    Format[Format["premodern"] = 18] = "premodern";
    Format[Format["oldschool"] = 19] = "oldschool";
})(Format = exports.Format || (exports.Format = {}));
var RelatedCardComponent;
(function (RelatedCardComponent) {
    RelatedCardComponent[RelatedCardComponent["token"] = 0] = "token";
    RelatedCardComponent[RelatedCardComponent["meld_part"] = 1] = "meld_part";
    RelatedCardComponent[RelatedCardComponent["meld_result"] = 2] = "meld_result";
    RelatedCardComponent[RelatedCardComponent["combo_piece"] = 3] = "combo_piece";
})(RelatedCardComponent = exports.RelatedCardComponent || (exports.RelatedCardComponent = {}));
let Scry;
const SYMBOL_CARD = Symbol("CARD");
class RelatedCard {
    static construct(card) {
        Object.setPrototypeOf(card, RelatedCard.prototype);
        return card;
    }
    get() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            return (_a = this[SYMBOL_CARD]) !== null && _a !== void 0 ? _a : (this[SYMBOL_CARD] = yield Scry.Cards.byId(this.id));
        });
    }
}
exports.RelatedCard = RelatedCard;
var PromoType;
(function (PromoType) {
    PromoType[PromoType["tourney"] = 0] = "tourney";
    PromoType[PromoType["prerelease"] = 1] = "prerelease";
    PromoType[PromoType["datestamped"] = 2] = "datestamped";
    PromoType[PromoType["planeswalkerdeck"] = 3] = "planeswalkerdeck";
    PromoType[PromoType["buyabox"] = 4] = "buyabox";
    PromoType[PromoType["judgegift"] = 5] = "judgegift";
    PromoType[PromoType["event"] = 6] = "event";
    PromoType[PromoType["convention"] = 7] = "convention";
    PromoType[PromoType["starterdeck"] = 8] = "starterdeck";
    PromoType[PromoType["instore"] = 9] = "instore";
    PromoType[PromoType["setpromo"] = 10] = "setpromo";
    PromoType[PromoType["fnm"] = 11] = "fnm";
    PromoType[PromoType["openhouse"] = 12] = "openhouse";
    PromoType[PromoType["league"] = 13] = "league";
    PromoType[PromoType["draftweekend"] = 14] = "draftweekend";
    PromoType[PromoType["gameday"] = 15] = "gameday";
    PromoType[PromoType["release"] = 16] = "release";
    PromoType[PromoType["intropack"] = 17] = "intropack";
    PromoType[PromoType["giftbox"] = 18] = "giftbox";
    PromoType[PromoType["duels"] = 19] = "duels";
    PromoType[PromoType["wizardsplaynetwork"] = 20] = "wizardsplaynetwork";
    PromoType[PromoType["premiereshop"] = 21] = "premiereshop";
    PromoType[PromoType["playerrewards"] = 22] = "playerrewards";
    PromoType[PromoType["gateway"] = 23] = "gateway";
    PromoType[PromoType["arenaleague"] = 24] = "arenaleague";
})(PromoType = exports.PromoType || (exports.PromoType = {}));
var CardFinish;
(function (CardFinish) {
    CardFinish[CardFinish["foil"] = 0] = "foil";
    CardFinish[CardFinish["nonfoil"] = 1] = "nonfoil";
    CardFinish[CardFinish["etched"] = 2] = "etched";
    CardFinish[CardFinish["glossy"] = 3] = "glossy";
})(CardFinish = exports.CardFinish || (exports.CardFinish = {}));
exports.CardFrame = {
    "1993": 0,
    "1997": 1,
    "2003": 2,
    "2015": 3,
    "Future": 4,
};
var CardStatus;
(function (CardStatus) {
    CardStatus[CardStatus["missing"] = 0] = "missing";
    CardStatus[CardStatus["placeholder"] = 1] = "placeholder";
    CardStatus[CardStatus["lowres"] = 2] = "lowres";
    CardStatus[CardStatus["highres_scan"] = 3] = "highres_scan";
})(CardStatus = exports.CardStatus || (exports.CardStatus = {}));
var CardSecurityStamp;
(function (CardSecurityStamp) {
    CardSecurityStamp[CardSecurityStamp["oval"] = 0] = "oval";
    CardSecurityStamp[CardSecurityStamp["triangle"] = 1] = "triangle";
    CardSecurityStamp[CardSecurityStamp["acorn"] = 2] = "acorn";
    CardSecurityStamp[CardSecurityStamp["circle"] = 3] = "circle";
    CardSecurityStamp[CardSecurityStamp["arena"] = 4] = "arena";
    CardSecurityStamp[CardSecurityStamp["heart"] = 5] = "heart";
})(CardSecurityStamp = exports.CardSecurityStamp || (exports.CardSecurityStamp = {}));
var CardIdentifier;
(function (CardIdentifier) {
    function byId(id) {
        return { id };
    }
    CardIdentifier.byId = byId;
    function byMtgoId(id) {
        return { mtgo_id: id };
    }
    CardIdentifier.byMtgoId = byMtgoId;
    function byMultiverseId(id) {
        return { multiverse_id: id };
    }
    CardIdentifier.byMultiverseId = byMultiverseId;
    function byOracleId(id) {
        return { oracle_id: id };
    }
    CardIdentifier.byOracleId = byOracleId;
    function byIllustrationId(id) {
        return { illustration_id: id };
    }
    CardIdentifier.byIllustrationId = byIllustrationId;
    function byName(name, set) {
        return { name, set };
    }
    CardIdentifier.byName = byName;
    function bySet(set, collectorNumber) {
        return { collector_number: `${collectorNumber}`, set };
    }
    CardIdentifier.bySet = bySet;
})(CardIdentifier = exports.CardIdentifier || (exports.CardIdentifier = {}));
let symbologyTransformer;
const REGEX_SYMBOLOGY = /{([a-z]|\d+)(?:\/([a-z]))?}/gi;
function transform(self, key, map) {
    const text = self[key];
    if (!text || !symbologyTransformer)
        return text;
    const transformerKey = typeof symbologyTransformer === "string" ? new String(symbologyTransformer) : symbologyTransformer;
    const value = map.get(transformerKey);
    if (value)
        return value;
    const transformed = typeof symbologyTransformer === "string"
        ? text.replace(REGEX_SYMBOLOGY, symbologyTransformer)
        : text.replace(REGEX_SYMBOLOGY, (_, type1, type2) => symbologyTransformer(type1, type2 !== null && type2 !== void 0 ? type2 : ""));
    map.set(transformerKey, transformed);
    return transformed;
}
class Card {
    static construct(card) {
        var _a;
        Object.setPrototypeOf(card, Card.prototype);
        if (!card.card_faces)
            card.card_faces = [{ object: "card_face" }];
        for (const face of card.card_faces)
            Object.setPrototypeOf(face, card);
        (_a = card.all_parts) === null || _a === void 0 ? void 0 : _a.forEach(RelatedCard.construct);
        return card;
    }
    getSet() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            return (_a = this[IScry_1.SYMBOL_SET]) !== null && _a !== void 0 ? _a : (this[IScry_1.SYMBOL_SET] = yield Scry.Sets.byId(this.set));
        });
    }
    getRulings() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            return (_a = this[IScry_1.SYMBOL_RULINGS]) !== null && _a !== void 0 ? _a : (this[IScry_1.SYMBOL_RULINGS] = yield Scry.Rulings.byId(this.id));
        });
    }
    getPrints() {
        var _a, _b, _c;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this[IScry_1.SYMBOL_PRINTS]) {
                this[IScry_1.SYMBOL_PRINTS] = yield Scry.Cards.search(`oracleid:${this.oracle_id}`, { unique: "prints" })
                    .waitForAll();
                for (const card of this[IScry_1.SYMBOL_PRINTS]) {
                    (_a = card[IScry_1.SYMBOL_SET]) !== null && _a !== void 0 ? _a : (card[IScry_1.SYMBOL_SET] = this[IScry_1.SYMBOL_SET]);
                    (_b = card[IScry_1.SYMBOL_RULINGS]) !== null && _b !== void 0 ? _b : (card[IScry_1.SYMBOL_RULINGS] = this[IScry_1.SYMBOL_RULINGS]);
                    (_c = card[IScry_1.SYMBOL_PRINTS]) !== null && _c !== void 0 ? _c : (card[IScry_1.SYMBOL_PRINTS] = this[IScry_1.SYMBOL_PRINTS]);
                }
            }
            return this[IScry_1.SYMBOL_PRINTS];
        });
    }
    getTokens() {
        return !this.all_parts ? []
            : this.all_parts.filter(part => part.component === "token");
    }
    /**
     * @returns `true` if this card is `legal` or `restricted` in the given format.
     */
    isLegal(format) {
        return this.legalities[format] === "legal" || this.legalities[format] === "restricted";
    }
    /**
     * @returns `true` if this card is `not_legal` or `banned` in the given format.
     */
    isIllegal(format) {
        return this.legalities[format] === "not_legal" || this.legalities[format] === "banned";
    }
    /**
     * @returns The `oracle_text` of this card, with symbols transformed by the transformer as set by @see {@link Cards.setSymbologyTransformer}
     */
    getText() {
        if (!this.hasOwnProperty(IScry_1.SYMBOL_TEXT))
            this[IScry_1.SYMBOL_TEXT] = new WeakMap;
        return transform(this, "oracle_text", this[IScry_1.SYMBOL_TEXT]);
    }
    /**
     * @returns The `mana_cost` of this card, with symbols transformed by the transformer as set by @see {@link Cards.setSymbologyTransformer}
     */
    getCost() {
        if (!this.hasOwnProperty(IScry_1.SYMBOL_COST))
            this[IScry_1.SYMBOL_COST] = new WeakMap;
        return transform(this, "mana_cost", this[IScry_1.SYMBOL_COST]);
    }
    getImageURI(version) {
        var _a, _b, _c;
        return (_b = (_a = this.image_uris) === null || _a === void 0 ? void 0 : _a[version]) !== null && _b !== void 0 ? _b : (_c = this.card_faces[0].image_uris) === null || _c === void 0 ? void 0 : _c[version];
    }
    getFrontImageURI(version) {
        var _a, _b, _c;
        return (_b = (_a = this.card_faces[0].image_uris) === null || _a === void 0 ? void 0 : _a[version]) !== null && _b !== void 0 ? _b : (_c = this.image_uris) === null || _c === void 0 ? void 0 : _c[version];
    }
    getBackImageURI(version) {
        var _a, _b;
        return this.layout !== "transform" && this.layout !== "double_faced_token"
            ? IScry_1.RESOURCE_GENERIC_CARD_BACK
            : (_b = (_a = this.card_faces[1].image_uris) === null || _a === void 0 ? void 0 : _a[version]) !== null && _b !== void 0 ? _b : IScry_1.RESOURCE_GENERIC_CARD_BACK;
    }
}
exports.Card = Card;
class Cards extends MagicQuerier_1.default {
    set Scry(scry) {
        Scry = scry;
    }
    setSymbologyTransformer(transformer) {
        symbologyTransformer = transformer;
        return this;
    }
    byName(name, set, fuzzy = false) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof set === "boolean") {
                fuzzy = set;
                set = undefined;
            }
            const promise = this.queryCard("cards/named", {
                [fuzzy ? "fuzzy" : "exact"]: name,
                set,
            });
            return promise;
        });
    }
    byId(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.queryCard(["cards", id]);
        });
    }
    bySet(setCode, collectorNumber, lang) {
        return __awaiter(this, void 0, void 0, function* () {
            const path = ["cards", typeof setCode === "string" ? setCode : setCode.code, collectorNumber];
            if (lang)
                path.push(lang);
            return this.queryCard(path);
        });
    }
    byMultiverseId(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.queryCard(["cards/multiverse", id]);
        });
    }
    byMtgoId(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.queryCard(["cards/mtgo", id]);
        });
    }
    byArenaId(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.queryCard(["cards/arena", id]);
        });
    }
    byTcgPlayerId(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.queryCard(["cards/tcgplayer", id]);
        });
    }
    byCardmarketId(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.queryCard(["cards/cardmarket", id]);
        });
    }
    random(query) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.queryCard("cards/random", { q: query });
        });
    }
    search(query, options) {
        const emitter = new MagicEmitter_1.default()
            .map(Card.construct);
        this.queryPage(emitter, "cards/search", Object.assign({ q: query }, typeof options === "number" ? { page: options } : options))
            .catch(err => emitter.emit("error", err));
        return emitter;
    }
    autoCompleteName(name) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.query("cards/autocomplete", { q: name })).data;
        });
    }
    collection(...identifiers) {
        const emitter = new MagicEmitter_1.default()
            .map(Card.construct);
        void this.processCollection(emitter, identifiers);
        return emitter;
    }
    queryCard(apiPath, query, post) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.query(apiPath, query, post)
                .then(Card.construct);
        });
    }
    processCollection(emitter, identifiers) {
        return __awaiter(this, void 0, void 0, function* () {
            for (let i = 0; i < identifiers.length; i += 75) {
                if (emitter.cancelled)
                    break;
                // the api only supports a max collection size of 75, so we take the list of identifiers (any length)
                // and split it into 75 card-max requests
                const collectionSection = { identifiers: identifiers.slice(i, i + 75) };
                const { data, not_found } = yield this.query("cards/collection", undefined, collectionSection);
                emitter.emitAll("not_found", ...not_found !== null && not_found !== void 0 ? not_found : []);
                if (!emitter.cancelled)
                    emitter.emitAll("data", ...data);
                if (emitter.willCancelAfterPage)
                    emitter.cancel();
            }
            if (!emitter.cancelled)
                emitter.emit("end");
            emitter.emit("done");
        });
    }
}
__decorate([
    Cached_1.default
], Cards.prototype, "byName", null);
__decorate([
    Cached_1.default
], Cards.prototype, "byId", null);
__decorate([
    Cached_1.default
], Cards.prototype, "bySet", null);
__decorate([
    Cached_1.default
], Cards.prototype, "byMultiverseId", null);
__decorate([
    Cached_1.default
], Cards.prototype, "byMtgoId", null);
__decorate([
    Cached_1.default
], Cards.prototype, "byArenaId", null);
__decorate([
    Cached_1.default
], Cards.prototype, "byTcgPlayerId", null);
__decorate([
    Cached_1.default
], Cards.prototype, "byCardmarketId", null);
__decorate([
    Cached_1.default
], Cards.prototype, "autoCompleteName", null);
exports.default = new Cards;
