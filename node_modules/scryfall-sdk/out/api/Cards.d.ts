import { Color, SYMBOL_COST, SYMBOL_PRINTS, SYMBOL_RULINGS, SYMBOL_SET, SYMBOL_TEXT } from "../IScry";
import MagicEmitter from "../util/MagicEmitter";
import MagicQuerier from "../util/MagicQuerier";
import { Ruling } from "./Rulings";
import { Set } from "./Sets";
export declare enum UniqueStrategy {
    cards = 0,
    art = 1,
    prints = 2
}
export declare enum Sort {
    name = 0,
    set = 1,
    released = 2,
    rarity = 3,
    color = 4,
    usd = 5,
    tix = 6,
    eur = 7,
    cmc = 8,
    power = 9,
    toughness = 10,
    edhrec = 11,
    artist = 12
}
export declare enum SortDirection {
    auto = 0,
    asc = 1,
    desc = 2
}
export interface SearchOptions {
    unique?: keyof typeof UniqueStrategy;
    order?: keyof typeof Sort;
    dir?: keyof typeof SortDirection;
    include_extras?: boolean;
    include_multilingual?: boolean;
    include_variations?: boolean;
    /**
     * The page to start on. Defaults to `1`, for first page. A page is 175 cards.
     */
    page?: number;
}
export declare enum Rarity {
    common = 0,
    uncommon = 1,
    rare = 2,
    special = 3,
    mythic = 4,
    bonus = 5
}
export declare enum FrameEffect {
    legendary = 0,
    miracle = 1,
    nyxtouched = 2,
    draft = 3,
    devoid = 4,
    tombstone = 5,
    colorshifted = 6,
    inverted = 7,
    sunmoondfc = 8,
    compasslanddfc = 9,
    originpwdfc = 10,
    mooneldrazidfc = 11,
    moonreversemoondfc = 12,
    showcase = 13,
    extendedart = 14,
    companion = 15,
    etched = 16,
    snow = 17,
    lesson = 18,
    shatteredglass = 19,
    convertdfc = 20,
    fandfc = 21,
    upsidedowndfc = 22
}
export declare enum Game {
    paper = 0,
    arena = 1,
    mtgo = 2
}
export declare enum Legality {
    legal = 0,
    not_legal = 1,
    restricted = 2,
    banned = 3
}
export declare enum Border {
    black = 0,
    borderless = 1,
    gold = 2,
    silver = 3,
    white = 4
}
export declare enum Layout {
    normal = 0,
    split = 1,
    flip = 2,
    transform = 3,
    modal_dfc = 4,
    meld = 5,
    leveler = 6,
    saga = 7,
    adventure = 8,
    planar = 9,
    scheme = 10,
    vanguard = 11,
    token = 12,
    double_faced_token = 13,
    emblem = 14,
    augment = 15,
    host = 16,
    art_series = 17,
    double_sided = 18
}
export declare enum Format {
    standard = 0,
    future = 1,
    historic = 2,
    gladiator = 3,
    pioneer = 4,
    explorer = 5,
    modern = 6,
    legacy = 7,
    pauper = 8,
    vintage = 9,
    penny = 10,
    commander = 11,
    oathbreaker = 12,
    brawl = 13,
    historicbrawl = 14,
    alchemy = 15,
    paupercommander = 16,
    duel = 17,
    premodern = 18,
    oldschool = 19
}
export type Legalities = {
    [key in keyof typeof Format]: keyof typeof Legality;
};
export interface ImageUris {
    small: string;
    normal: string;
    large: string;
    png: string;
    art_crop: string;
    border_crop: string;
}
export interface Prices {
    usd?: string | null;
    usd_foil?: string | null;
    usd_etched?: string | null;
    eur?: string | null;
    eur_foil?: string | null;
    tix?: string | null;
}
export interface PurchaseUris {
    tcgplayer?: string | null;
    cardmarket?: string | null;
    cardhoarder?: string | null;
    [key: string]: string | null | undefined;
}
export interface RelatedUris {
    gatherer?: string | null;
    tcgplayer_decks?: string | null;
    tcgplayer_infinite_decks?: string | null;
    tcgplayer_infinite_articles?: string | null;
    edhrec?: string | null;
    mtgtop8?: string | null;
    [key: string]: string | null | undefined;
}
export declare enum RelatedCardComponent {
    token = 0,
    meld_part = 1,
    meld_result = 2,
    combo_piece = 3
}
declare const SYMBOL_CARD: unique symbol;
export declare class RelatedCard {
    object: "related_card";
    id: string;
    component: keyof typeof RelatedCardComponent;
    name: string;
    type_line: string;
    uri: string;
    static construct(card: RelatedCard): RelatedCard;
    private [SYMBOL_CARD]?;
    get(): Promise<Card>;
}
interface CardFaceMethods {
    getText(): string | null | undefined;
    getCost(): string | null | undefined;
    getImageURI(version: keyof ImageUris): string | null | undefined;
}
export interface CardFace extends CardFaceMethods {
    object: "card_face";
    artist?: string | null;
    artist_id?: string | null;
    cmc?: number | null;
    color_indicator?: Color[] | null;
    colors?: Color[] | null;
    defense?: string | null;
    flavor_text?: string | null;
    illustration_id?: string | null;
    image_uris?: ImageUris | null;
    layout?: string | null;
    loyalty?: string | null;
    mana_cost?: string | null;
    name: string;
    oracle_id?: string | null;
    oracle_text?: string | null;
    power?: string | null;
    printed_name?: string | null;
    printed_text?: string | null;
    printed_type_line?: string | null;
    toughness?: string | null;
    type_line?: string | null;
    watermark?: string | null;
}
export interface Preview {
    previewed_at?: string | null;
    source_uri?: string | null;
    source?: string | null;
}
export declare enum PromoType {
    tourney = 0,
    prerelease = 1,
    datestamped = 2,
    planeswalkerdeck = 3,
    buyabox = 4,
    judgegift = 5,
    event = 6,
    convention = 7,
    starterdeck = 8,
    instore = 9,
    setpromo = 10,
    fnm = 11,
    openhouse = 12,
    league = 13,
    draftweekend = 14,
    gameday = 15,
    release = 16,
    intropack = 17,
    giftbox = 18,
    duels = 19,
    wizardsplaynetwork = 20,
    premiereshop = 21,
    playerrewards = 22,
    gateway = 23,
    arenaleague = 24
}
export declare enum CardFinish {
    foil = 0,
    nonfoil = 1,
    etched = 2,
    glossy = 3
}
export declare const CardFrame: {
    "1993": number;
    "1997": number;
    "2003": number;
    "2015": number;
    Future: number;
};
export declare enum CardStatus {
    missing = 0,
    placeholder = 1,
    lowres = 2,
    highres_scan = 3
}
export declare enum CardSecurityStamp {
    oval = 0,
    triangle = 1,
    acorn = 2,
    circle = 3,
    arena = 4,
    heart = 5
}
export interface CardIdentifier {
    id?: string;
    mtgo_id?: number;
    multiverse_id?: number;
    oracle_id?: string;
    illustration_id?: string;
    name?: string;
    set?: string;
    collector_number?: string;
}
export declare namespace CardIdentifier {
    function byId(id: string): CardIdentifier;
    function byMtgoId(id: number): CardIdentifier;
    function byMultiverseId(id: number): CardIdentifier;
    function byOracleId(id: string): CardIdentifier;
    function byIllustrationId(id: string): CardIdentifier;
    function byName(name: string, set?: string): CardIdentifier;
    function bySet(set: string, collectorNumber: string | number): CardIdentifier;
}
/**
 * A transformer that replaces symbols as seen in `mana_cost` and `oracle_text` in the format: `{G}`, `{8}`, `{U/W}`, etc.
 *
 * A transformer will be given a type, and a potential second type (in the case of `{T/T}`),
 * and produce a string to replace the symbol in the text.
 */
export type SymbologyTransformer = (type: string, type2?: string) => string;
export type Modifier = `+${bigint}` | `-${bigint}`;
export type AttractionLight = 1 | 2 | 3 | 4 | 5 | 6;
export declare class Card implements CardFaceMethods {
    object: "card";
    arena_id?: number | null;
    id: string;
    lang: string;
    mtgo_id?: number | null;
    mtgo_foil_id?: number | null;
    multiverse_ids?: number[] | null;
    tcgplayer_id?: number | null;
    tcgplayer_etched_id?: number | null;
    cardmarket_id?: number | null;
    oracle_id: string;
    layout: keyof typeof Layout;
    prints_search_uri: string;
    rulings_uri: string;
    scryfall_uri: string;
    uri: string;
    all_parts?: RelatedCard[] | null;
    card_faces: CardFace[];
    cmc: number;
    color_identity: Color[];
    color_indicator?: Color[] | null;
    colors?: Color[] | null;
    edhrec_rank?: number | null;
    hand_modifier?: Modifier | null;
    keywords: string[];
    legalities: Legalities;
    life_modifier?: Modifier | null;
    loyalty?: string | null;
    mana_cost?: string | null;
    name: string;
    oracle_text?: string | null;
    penny_rank?: number | null;
    power?: string | null;
    produced_mana?: Color[] | null;
    reserved: boolean;
    toughness?: string | null;
    type_line: string;
    artist?: string | null;
    artist_ids?: string[] | null;
    attraction_lights?: AttractionLight[] | null;
    booster: boolean;
    border_color: keyof typeof Border;
    card_back_id: string;
    collector_number: string;
    content_warning?: boolean | null;
    digital: boolean;
    finishes: (keyof typeof CardFinish)[];
    flavor_name?: string | null;
    flavor_text?: string | null;
    frame_effects?: (keyof typeof FrameEffect)[] | null;
    frame: keyof typeof CardFrame;
    full_art: boolean;
    games: (keyof typeof Game)[];
    highres_image: boolean;
    illustration_id?: string | null;
    image_status: keyof typeof CardStatus;
    image_uris?: ImageUris | null;
    oversized: boolean;
    prices: Prices;
    printed_name?: string | null;
    printed_text?: string | null;
    printed_type_line?: string | null;
    promo: boolean;
    /**
     * Note: This may return other values, I can't check if the possible strings have changed because the Scryfall docs
     * no longer list the possible promo types.
     */
    promo_types?: (keyof typeof PromoType)[] | null;
    purchase_uris?: PurchaseUris | null;
    rarity: keyof typeof Rarity;
    related_uris: RelatedUris;
    released_at: string;
    reprint: boolean;
    scryfall_set_uri: string;
    set_name: string;
    set_search_uri: string;
    set_type: Set["set_type"];
    set_uri: string;
    set: string;
    set_id: string;
    story_spotlight: boolean;
    textless: boolean;
    variation: boolean;
    variation_of?: string | null;
    security_stamp?: (keyof typeof CardSecurityStamp)[] | null;
    watermark?: string | null;
    preview?: Preview | null;
    static construct(card: Card): Card;
    private [SYMBOL_SET]?;
    getSet(): Promise<Set>;
    private [SYMBOL_RULINGS]?;
    getRulings(): Promise<Ruling[]>;
    private [SYMBOL_PRINTS]?;
    getPrints(): Promise<Card[]>;
    getTokens(): RelatedCard[];
    /**
     * @returns `true` if this card is `legal` or `restricted` in the given format.
     */
    isLegal(format: keyof typeof Format): boolean;
    /**
     * @returns `true` if this card is `not_legal` or `banned` in the given format.
     */
    isIllegal(format: keyof typeof Format): boolean;
    private [SYMBOL_TEXT];
    /**
     * @returns The `oracle_text` of this card, with symbols transformed by the transformer as set by @see {@link Cards.setSymbologyTransformer}
     */
    getText(): string | null | undefined;
    private [SYMBOL_COST];
    /**
     * @returns The `mana_cost` of this card, with symbols transformed by the transformer as set by @see {@link Cards.setSymbologyTransformer}
     */
    getCost(): string | null | undefined;
    getImageURI(version: keyof ImageUris): string | undefined;
    getFrontImageURI(version: keyof ImageUris): string | undefined;
    getBackImageURI(version: keyof ImageUris): string;
}
declare class Cards extends MagicQuerier {
    protected set Scry(scry: typeof import("../Scry"));
    setSymbologyTransformer(transformer?: string | SymbologyTransformer): this;
    byName(name: string, fuzzy?: boolean): Promise<Card>;
    byName(name: string, set?: string, fuzzy?: boolean): Promise<Card>;
    byId(id: string): Promise<Card>;
    bySet(setCode: string | Set, collectorNumber: string | number, lang?: string): Promise<Card>;
    byMultiverseId(id: number): Promise<Card>;
    byMtgoId(id: number): Promise<Card>;
    byArenaId(id: number): Promise<Card>;
    byTcgPlayerId(id: number): Promise<Card>;
    byCardmarketId(id: number): Promise<Card>;
    random(query?: string): Promise<Card>;
    /**
     * Returns a MagicEmitter of every card in the Scryfall database that matches the given query.
     */
    search(query: string, options?: SearchOptions): MagicEmitter<Card>;
    /**
     * Returns a MagicEmitter of every card in the Scryfall database that matches the given query.
     */
    search(query: string, page?: number): MagicEmitter<Card>;
    /**
     * Returns a MagicEmitter of every card in the Scryfall database that matches the given query.
     */
    search(query: string, options?: SearchOptions | number): MagicEmitter<Card>;
    autoCompleteName(name: string): Promise<string[]>;
    collection(...identifiers: CardIdentifier[]): MagicEmitter<Card, CardIdentifier>;
    private queryCard;
    private processCollection;
}
declare const _default: Cards;
export default _default;
