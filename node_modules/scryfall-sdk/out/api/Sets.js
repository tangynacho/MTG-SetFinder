"use strict";
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Set = void 0;
const IScry_1 = require("../IScry");
const Cached_1 = require("../util/Cached");
const MagicQuerier_1 = require("../util/MagicQuerier");
var SetType;
(function (SetType) {
    SetType[SetType["core"] = 0] = "core";
    SetType[SetType["expansion"] = 1] = "expansion";
    SetType[SetType["masters"] = 2] = "masters";
    SetType[SetType["alchemy"] = 3] = "alchemy";
    SetType[SetType["masterpiece"] = 4] = "masterpiece";
    SetType[SetType["arsenal"] = 5] = "arsenal";
    SetType[SetType["from_the_vault"] = 6] = "from_the_vault";
    SetType[SetType["spellbook"] = 7] = "spellbook";
    SetType[SetType["premium_deck"] = 8] = "premium_deck";
    SetType[SetType["duel_deck"] = 9] = "duel_deck";
    SetType[SetType["draft_innovation"] = 10] = "draft_innovation";
    SetType[SetType["treasure_chest"] = 11] = "treasure_chest";
    SetType[SetType["commander"] = 12] = "commander";
    SetType[SetType["planechase"] = 13] = "planechase";
    SetType[SetType["archenemy"] = 14] = "archenemy";
    SetType[SetType["vanguard"] = 15] = "vanguard";
    SetType[SetType["funny"] = 16] = "funny";
    SetType[SetType["starter"] = 17] = "starter";
    SetType[SetType["box"] = 18] = "box";
    SetType[SetType["promo"] = 19] = "promo";
    SetType[SetType["token"] = 20] = "token";
    SetType[SetType["memorabilia"] = 21] = "memorabilia";
    SetType[SetType["minigame"] = 22] = "minigame";
})(SetType || (SetType = {}));
let Scry;
class Set {
    static construct(set) {
        Object.setPrototypeOf(set, Set.prototype);
        return set;
    }
    getCards(options) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!options)
                return (_a = this[IScry_1.SYMBOL_CARDS]) !== null && _a !== void 0 ? _a : (this[IScry_1.SYMBOL_CARDS] = yield this.search(`s:${this.code}`, { order: "set" }));
            return this.search(`s:${this.code}`, Object.assign({ order: "set" }, options));
        });
    }
    search(query, options) {
        return Scry.Cards.search(`s:${this.code} ${query}`, options)
            .map(card => {
            var _a;
            (_a = card[IScry_1.SYMBOL_SET]) !== null && _a !== void 0 ? _a : (card[IScry_1.SYMBOL_SET] = this);
            return card;
        })
            .waitForAll();
    }
}
exports.Set = Set;
class Sets extends MagicQuerier_1.default {
    set Scry(scry) {
        Scry = scry;
    }
    all() {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.query("sets")).data
                .map(Set.construct);
        });
    }
    byCode(code) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.querySet(["sets", code]);
        });
    }
    byId(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.querySet(["sets", id]);
        });
    }
    byTcgPlayerId(id) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.querySet(["sets/tcgplayer", id]);
        });
    }
    /**
     * @param fuzzy This parameter only works if you've previously set a fuzzy comparer with `Scry.setFuzzySearch`. Otherwise it only returns exact matches.
     */
    byName(name, fuzzy) {
        return __awaiter(this, void 0, void 0, function* () {
            const all = yield this.all();
            let result;
            if (fuzzy && IScry_1.IScry.fuzzySearch)
                result = IScry_1.IScry.fuzzySearch(name, all, "name");
            else {
                name = name.toLowerCase();
                result = all.find(set => set.name.toLowerCase() === name);
            }
            if (result)
                return result;
            const error = new Error(`No sets found matching “${name}”`);
            error.status = 404;
            error.code = "not_found";
            throw error;
        });
    }
    querySet(apiPath, query, post) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.query(apiPath, query, post)
                .then(Set.construct);
        });
    }
}
__decorate([
    Cached_1.default
], Sets.prototype, "all", null);
__decorate([
    Cached_1.default
], Sets.prototype, "byCode", null);
__decorate([
    Cached_1.default
], Sets.prototype, "byId", null);
__decorate([
    Cached_1.default
], Sets.prototype, "byTcgPlayerId", null);
__decorate([
    Cached_1.default
], Sets.prototype, "byName", null);
exports.default = new Sets;
